---
output: github_document
authors: 
  - Simon J. Kiss
  - Matthew Polacko
  - Peter Graefe
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
library(knitr)
knitr::opts_chunk$set(
  results='markup',
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%",
  warning=F, message=F
)
```

# Introduction

<!-- badges: start -->
<!-- badges: end -->

The goal of this package is to facilitate collaboration and research on the full life cycle of the Canada Election Study.

It solves two problems.

First, it stores all extant CES data files in one spot, quickly loadable in R. Second, it makes available work conducted by Matt Polacko and Simon Kiss to systematically name and recode variables through the lifecycle of the CES. Both are obstacles to research in Canadian politics. 

## Installation

You can install the development version of `cesdata2` from [GitHub](https://github.com/) with:

``` r
# install.packages("devtools")
devtools::install_github("sjkiss/cesdata2")
```

## How to use it.

Once installed, individual datasets are available by calling:

```{r example}
library(cesdata2)
## basic example code
data("ces65")
data("ces68")

```

These are the datasets currently available with the names required to load them. 

| Dataset title | Filename | Notes |
|:---------------------------| ----------------------:|:----------------------:|
| CES 1965 | `ces65`|  |
| CES 1968  | `ces68`|  | 
| CES 1972 | `ces72_nov` | Only the November, post-election dataset is included |
| CES 1974-1979-1980 | ces7980 | Notes about who is included in the 1980 dataset, how variables were used?? |
| CES 1984  | `ces84` |  |
| CES 1988 | `ces88` |  |
| CES 1993 | `ces93` | Notes about Quebec referendum sample? |
| CES 2000 | `ces00` |  |
| CES 2004-2006-2008-2011  | `ces0411` | this is the combined file for campaign period, post-election and mailback surveys for each of four federal elections. It requires special handling in the construction of a master dataset. See below. |
| CES 2015 Phone | `ces15phone` | Phone survey from 2015 |
| CES 2015 Web | `ces15web` | Web survey from 2015 |
| CES 2019 Phone | `ces19phone` | Phone survey from 2019 |
| CES 2019 Web | `ces19web` | Phone survey from 2019 |

# Recoded variables

Polacko and Kiss (particularly the former) have gone to great lengths to recode and rename variables of interest to allow for combination into a single tabular dataset that allows for time series analysis. 

Wherever possible, the following conventions have been used.

1. Likert items have been rescaled from 0 to 1
2. Liberal views are scored 0 and conservative views are scaled high.

This is an incomplete list of recoded and renamed variables. 

| Concept | Variable Name | notes|
|:---------------------------| ----------------------:|:----------------------:|
| This | This| This |
| column  | column | column | 
| will | be | aligned |
| left | right | center |

## How are variables recoded

Currently the `cesdata2` package comes with two files for each Canada Election Study. 

1. A raw, unedited data file from publicly available libraries of the CES studies, in either SPSS or Stata format. These files are stored in the package's `data-raw` subfolder.

```{r data-raw}
list.files(path="data-raw")
```

2. An `.rda` file for each that contains the results of our recode scripts. That is to say, it includes recoded variables using our systematic conventions. These are stored in the package's `data` subfolder. 

```{r data}
list.files(path="data")
```

The recode scripts themselves are stored in the package subfolder `data-raw/recode_scripts/`.

Users invited to the project are invited to begin constructing a tabular data frame, right away making use of our recoded variables. However, users are also welcome to contribute to the package's development by adding new recodes in the recode scripts. The next section shows how to do that:

### Adding recoded variables

1. Users must clone the package's GitHub repository to their desktop. Instructions on how to do this can be found [here](https://happygitwithr.com/existing-github-first), particularly Section 16.2.2.  

2. That done, open the RStudio project in the local directory you have just created on your computer which is a clone of the existing package repository. 

3. Open the recode script for the data-set you want to work on. Here, you will need to navigate to the folder `data-raw/recode_scripts/` and select which one you want. 

4. You probably want to load the data-set, here by running this command. 
```{r eval=F}
data("ces04011")
```

In this way you will be able to execute, see and diagnose recode commands in the local environment. 

5. Once complete, you will need to `source()` the recode script from beginning to end. This is important for a few reasons. First, running `source()` is *noticeably* faster than executing code by selecting it in RStudio and running cmd-Enter. We have been doing this and it can take forever. 

Second, and more importantly, you will see that the recode script always starts by loading the original raw data file and then saving an `.rdata` file out into the folder `data`. *This* is the file that is available to users when they 

6. After sourcing all recode scripts, it is necessary to re-build and re-install the package. Once you have done this, you can: 1) exit the package, 2) Open a new RScript for analysis (which should be an RStudio project) 3) call `library(cesdata2)` and your recoded variables should be available to you.

7. To share with other users, which is highly desirable, *re-open the `cesdata2`* project on your computer, make a new Github branch, using an informative title, commit these changes to the GitHub repository and push them to that new branch, *not* the main branch.

The package is currently set up to permit only Simon Kiss and Matt Polacko to contribute to the main branch. All others must commit to other branches. Simon Kiss, package maintainer, will merge branches to the main branch and communicate when that has happened.

## Constructing a dataset for analysis.

In the simple case of combinining three single-election datasets, we can combine them in this way.

```{r load-data}
#First load the datasets
data("ces93")
data("ces97")
data("ces00")

```
Next, it is necessary to take the variables of interest and select them from each dataset. There are many ways to do this, but this is a quick way.

1. Make a list of your datasets.
2. Provide names for each list item, corresponding to the election year
3. Make a separate vector of all the variable names you want to select
4. Combine `map()` and `select(any_of())` and `list_rbind()`to select those variables and join them together in a tabular data frame.

```{r list-data}
#make a list of datasets
ces.list<-list(ces00, ces93, ces97)
#Make a vector of desired common variables
myvars<-c("male", "degree")
library(tidyverse)
library(haven) #necessary to zap labels
ces.list %>% 
  map(., select, any_of(myvars)) %>% 
  list_rbind(., names_to=c("election"))

  
```

### Issues and Special Cases

1. A variable is not in one of the datasets.

One of the desirable aspects for using the approach of defining common variables and then mapping the `select()` function to each data frame in a list outlined above is that it will still add a CES data frame to the master data frame, even if it does not have the renamed and recoded variable. It will simply populate rows from that data frame with `NA`. 

Consider the variable `gay_rights`, it only starts in CES 1993. But it is plausible to imagine a research project where attitudes to gay rights are only one part of the project and one wishes to use data from CES 1988 for other parts.  


```{r issue-1}
#Load data sets
data("ces84")
data("ces88")
data("ces93")
data("ces97")
data("ces00")
# Construct the list
ces.list<-list(ces84,ces88, ces93, ces97, ces00)
#names
names(ces.list)<-c(1984,1988, 1993, 1997, 2000)
# Check to see if ces84 gay_rights exists
length(ces84$gay_rights) # Zero indicates it does not exist
#Check to see if ces88 gay_rights exists
length(ces88$gay_rights) #3609 cases of gay_rights values
# Construct common variables
myvars<-c("gender", "vote", "gay_rights")
#Make data frame
ces.list %>% 
  #Zap the labels
  map(., zap_labels) %>% 
  #Select the variables
  map(., select, any_of(myvars)) %>% 
  #bind together providing a new variable Election containing the election year
  list_rbind(., names_to=c("Election"))->ces

```
Now we can confirm what was happen with the variable `gay_rights` in each year.

```{r show-gay-rights-84}
#Check the gay_rights variable in 1984
ces %>% 
  filter(Election==1984) %>% 
  select(gay_rights)

```

```{r show-gay-rights-88}
#Check the gay_rights variable in 1988
ces %>% 
  filter(Election==1988) %>% 
  select(gay_rights)
```



2. Panel datasets

There are two panel sets in the complete series, 1979-1980 and 2004-2006-2008-2011. These present some challenges for the strategy we chose of consistently renaming variables. 

The underlying data files look like this the following table, for *each* respondent, there are variables for the 2004, 2006, and 2008 surveys *whether or not* the respondent actually completed the surveys. 



Respondent ID |Survey |`ces04_PES_K5A` | `ces06_PES_B4A` |`ces08_PES_B4B`  | 
|:-----:|:-----:|:---------------------------:| :----------------------:| :-------:|
| 1|2004 | `Refused` | NA| NA|
| 2|2006 | NA  | Liberal Party of Canada |NA| 
|3 |2008| NA | NA | NDP
|4 |2004 and 2006| Other | Liberal Party of Canada | NA|
|5 | 2006 and 2008 | NA | 

Ultimately, each of these columns measure the same variable, the person's vote cast, but at different time periods. As currently constructed, the 2004-2006-2008-2011 will not permit the same name, e.g. `vote` to be used in more than one column.

As a result, we use the following naming conventions in this data-set for variables that have been recoded (e.g. small parties excluded,  `Don't Know` responses set to `NA`, `Refused` set to `NA`, etc. )

Respondent ID |Survey |`ces04_PES_K5A` | `ces06_PES_B4A` |`ces08_PES_B4B`  | `vote04`| `vote06`| `vote08`| 
|:-----:|:-----:|:---------------------------:| :----------------------:|:-------:|:------:|:------:|:-------:|
| 1|2004 | `Refused` | NA| NA| NA| NA| NA|
| 2|2006 | NA  | Liberal Party of Canada |NA| NA | Liberal | NA| 
|4 |2004 and 2006| Other | Liberal | NA| NA | Liberal | NA|

In order to combine these variables successfully into one tabular dataset, it is first necessary to: 1) split the 2004-2011 dataset into separate datasets for each time election, 2) rename the variables taking out the year indicators, 3) add the split datasets to the list of CES data sets and then recombine. 

We could have separated the each election dataset into a separate one in the backend, however, there is a lot of overlap in respondent participation. We did not want to presume how analysts would want to proceed selecting which respondents who took which surveys should be counted in or not. There are advantages and disadvantages to different approaches. So, as a result this step needs to be combined with a step where the researcher specifies which of these surveys you wish to use. Here is the problem....

```{r survey-participation, echo=F}

table(ces0411$survey) %>% 
  knitr::kable()

```

There are multiple ways to split the file.  You can split it very precisely and narrowly.  For example, one can pick only the respondents who completed the CPS04, the CPS04 PES04 or the CPS04 PES04 MBS04 sequence by using `filter()` and a regular epression in `str_detect()`. Note, to diagnose the accuracy of your regular expressin and filter strategy, you can first `select()` only the `survey` variable and count what your filter strategy produces, and then actually filter into a new data frame.  

```{r include-only-cps04}
ces0411 %>% 
  select(survey) %>% 
  filter(survey=="CPS04") %>% 
  count(survey) %>% 
  kable()
```

```{r include-only-cps04-pes04}
ces0411 %>% 
  select(survey) %>% 
  filter(survey=="CPS04"|survey=="CPS04 PES04"|survey=="CPS04 PES04 MBS04") %>% 
  count(survey) %>% 
  kable()
```

When satisfied, it is essential of course to save the results in a single-year dataset.

```{r }
ces0411 %>% 
  filter(survey=="CPS04"|survey=="CPS04 PES04"|survey=="CPS04 PES04 MBS04")->
# Note we are making a new ces04 object that corresponds in naming to all other election year files
ces04

#One can compare the rows
nrow(ces0411)
nrow(ces04)
```

Please note how this interacts with the above strategy of providing renamed and recoded variables for each variable. The respondents in `ces04` *never had the chance to participate in any other year surveys*. But they will have variables in the new `ces04` dataset for later year variabes; they will simply all be `NA`.

```{r ces04-NA}
#Note I am using the ces04 dataframe
ces04 %>% 
  select(vote04, vote06, vote08, vote11) %>% 
  slice_sample(n=20) %>% 
  kable()
```

Please note that alternative, more expansive selection strategies are available. 
For example, we can collect *any* respondent who responded to any survey by using `str_detect()`. 
You can see the effects of such a strategy here:

```{r}
ces0411 %>% 
  select(survey) %>% 
  filter(str_detect(survey, "PES08")) %>% 
  count(survey) %>% 
  kable()
```

This might be desirable to increase sample size, but it might be undesirable to include panel respondents, who, after having been interviewed multiple times, may be demonstrate different responses than other purely cross-sectional respondents. We leave this to the user.

For now, we will keep the filtering strategy and save the resulting object as `ces08`.
```{r make-ces08}
ces0411 %>% 
  filter(str_detect(survey, "PES08"))->ces08
```

3. Renaming re-coded variables in `ces04`, `ces06`, `ces08` and `ces11` data frames.

Because respondents in`ces04` and `ces08` all come from the giant combined file, all have recoded variables from each election. For variables they were not eligible to report because they weren't in that survey, their values are `NA`
```{r}
ces04 %>% 
select(contains('vote'))

```
Note, because we used an expansive filtering strategy for `ces08` there are respondents who actully have responses for variables from 2004. However, because we are defining this as a dataset for 2008, we will effectively drop those earlier responses and only take respondents' values from 2008. 
```{r}
ces08 %>% 
  select(contains('vote')) 

```


The most straightforward way to do this is to strip out year identifying numbers from the variables you *want* to keep. 

So, for the `ces04` dataset, we want to keep the variables recoded with `04` appended. You can do this really quickly with the `clean_names()` function in the `janitor` package. 

```{r ces04-select-04-variables}
library(janitor)
ces04 %>% 
  clean_names(., replace=c("vote04"="vote", 
              "gender04"="gender", 
              "degree04"="degree")) %>% 
  select(survey, vote, gender, degree)->ces04
#Check the names
names(ces04)
```
And for `ces08`

```{r}
ces08 %>% 
  clean_names(., replace=c("gender08"="gender",
                           "degree08"="degree",
                           "vote08"="vote")) %>% 
  select(gender, degree, vote)->ces08
#names(ces08)
```

And now, we could proceed, as noted above, creating a unified tabular ces dataset from with other, more simple, one-election datafiles.

```{r ces08-select-08-variables}
data("ces93")
data("ces97")
data("ces00")
#List the data frames to be used.
ces.list<-c(ces93, ces97, ces00, ces04, ces08)
#Provide names
names(ces.list)<-c(1993, 1997, 2000, 2004, 2008)
```


3. The 1980 Canada Election Study

Something happened in the 1980 election because it was called so quickly, the CES team was not able to field a full survey or something. As a result, some demographic variables were not asked. 


# Outstanding Issues

1. It would be desirable to add a `mode` variable in the recode scripts so that potentially phone and web surveys from 2015 and 2019 could be used in the same analysis and the analyst could distinguish which mode provided the case. The consistent naming scheme could remain for common variables (e.g. `male` for male gendered people, `vote` for vote cast), but then there could be 

2. Value labels

Right now, all the original CES files are imported via the `haven` package which creates this very awkwared `labelled` class variable instead of standard R factors. In hindsight this was a mistake. It would be better to go back and convert those variables as value labels straight to factors. 

## References
